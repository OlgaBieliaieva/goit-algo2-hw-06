# Робота з даними


## Завдання 1. 
### Перевірка унікальності паролів за допомогою фільтра Блума

Створіть функцію для перевірки унікальності паролів за допомогою фільтра Блума. 
Ця функція має визначати, чи використовувався пароль раніше, без необхідності зберігати самі паролі.


#### Технічні умови

1. Реалізуйте клас BloomFilter, який забезпечує додавання елементів до фільтра та перевірку наявності елемента у фільтрі.

2. Реалізуйте функцію check_password_uniqueness, яка використовує екземпляр BloomFilter та перевіряє список нових паролів на унікальність. Вона має повертати результат перевірки для кожного пароля.

3. Забезпечте коректну обробку всіх типів даних. Паролі слід обробляти просто як рядки, без хешування. Порожні або некоректні значення також мають бути враховані та оброблені належним чином.

4. Функція та клас мають працювати з великими наборами даних, використовуючи мінімум пам’яті.


#### Критерії прийняття
1. Клас BloomFilter реалізує логіку роботи з фільтром Блума (20 балів).

2. Функція check_password_uniqueness перевіряє нові паролі, використовуючи переданий фільтр (20 балів).

3. Код виконує приклад використання відповідно до очікуваних результатів (10 балів).


#### Приклад використання

```
if __name__ == "__main__":
    # Ініціалізація фільтра Блума
    bloom = BloomFilter(size=1000, num_hashes=3)

    # Додавання існуючих паролів
    existing_passwords = ["password123", "admin123", "qwerty123"]
    for password in existing_passwords:
        bloom.add(password)

    # Перевірка нових паролів
    new_passwords_to_check = ["password123", "newpassword", "admin123", "guest"]
    results = check_password_uniqueness(bloom, new_passwords_to_check)

    # Виведення результатів
    for password, status in results.items():
        print(f"Пароль '{password}' - {status}.")

``` 

#### Результат

```
Пароль 'password123' — вже використаний.
Пароль 'newpassword' — унікальний.
Пароль 'admin123' — вже використаний.
Пароль 'guest' — унікальний.

```

### Рішення:
1. Створено клас BloomFilter, який реалізує:

- Ініціалізацію бітового масиву заданого розміру.

- Обчислення кількох хешів для кожного елемента за допомогою бібліотеки mmh3.

- Методи add() та contains() для додавання й перевірки елементів.

2. Реалізовано REST API на FastAPI, що:

- Приймає список паролів (POST /check-passwords).

- Для кожного пароля визначає:

    - унікальний — якщо раніше не зустрічався;

    - вже використаний — якщо є в фільтрі;

    - некоректний пароль — якщо пустий або не рядок.

- Використовує глобальний об’єкт Bloom Filter для збереження стану між запитами.

3. Перевірено роботу сервісу через Swagger UI та локально.